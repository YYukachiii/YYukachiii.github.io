<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SPiCa</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyukachiiii.github.io/child/"/>
  <updated>2019-09-11T07:00:44.816Z</updated>
  <id>http://yyukachiiii.github.io/child/</id>
  
  <author>
    <name>SPiCa_zY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用PyTorch学习NLP Chapter 1.神经网络基础组件</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/10/NLP/Chap.3/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/10/NLP/Chap.3/</id>
    <published>2019-09-10T06:31:09.000Z</published>
    <updated>2019-09-11T07:00:44.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-3-神经网络基础组件"><a href="#Chapter-3-神经网络基础组件" class="headerlink" title="Chapter 3.神经网络基础组件"></a>Chapter 3.神经网络基础组件</h1><h2 id="Perceptron-The-Simplest-Neural-Network"><a href="#Perceptron-The-Simplest-Neural-Network" class="headerlink" title="Perceptron: The Simplest Neural Network"></a>Perceptron: The Simplest Neural Network</h2><p>​    图解感知机结构：(图的链接是在是太长了，要考虑一下解决办法)</p><p><img src="data:image/png;base64,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" alt="avatar"></p><p>​    激活函数的选择有很多种，这里选择了Sigmoid函数。</p><h2 id="Activation-Functions"><a href="#Activation-Functions" class="headerlink" title="Activation Functions"></a>Activation Functions</h2><p>​    这里列出本书中用到的四个激活函数：(都已经比较熟悉了，就不多做解释了)</p><ul><li><p>Sigmod</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.range(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = torch.sigmoid(x)</span><br></pre></td></tr></table></figure></li><li><p>Tanh</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.range(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = torch.tanh(x)</span><br></pre></td></tr></table></figure></li><li><p>ReLU</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.range(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = torch.relu(x)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Softmax</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">softmax = torch.nn.Softmax(dim=<span class="number">1</span>)</span><br><span class="line">x = torch.randn(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">y = softmax(x)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h2><ul><li>Mean Squared Error Loss</li><li>Categorical Cross-Entropy Loss<ul><li>PyTorch中的计算交叉熵的对象的输入是未经过Softmax变换的预测值和各个样本的类标号构成的向量(为转换成One-hot向量)</li></ul></li><li>Binary Cross-Entropy<ul><li>不同于Categorical Cross-Entropy Loss，二元交叉熵的输入是预测值的概率分布和样本的类标号构成的向量</li><li>逻辑回归的损失函数实际上就是二元交叉熵损失</li></ul></li></ul><h2 id="Diving-Deep-into-Supervised-Training"><a href="#Diving-Deep-into-Supervised-Training" class="headerlink" title="Diving Deep into Supervised Training"></a>Diving Deep into Supervised Training</h2><p>​    统计学习方法的三要素：</p><ul><li>模型</li><li>策略(经验风险最小化、结构风险最小化)</li><li>算法(BP等等)</li></ul><p>​    完成一个有监督学习任务还需要训练数据。</p><h3 id="Putting-It-Together-Gradient-Based-Supervised-Learning"><a href="#Putting-It-Together-Gradient-Based-Supervised-Learning" class="headerlink" title="Putting It Together:Gradient-Based Supervised Learning"></a>Putting It Together:Gradient-Based Supervised Learning</h3><p>​    PyTorch完成一个学习过程的步骤如下：</p><ul><li><p>选择模型和用于训练模型的数据</p></li><li><p>使用名为zero_grad()的函数清除存储在模型对象中的所有信息(如梯度)</p></li><li><p>模型计算给定输入数据(x_data)的输出(y_pred)</p></li><li><p>计算损失函数，通过比较模型输出(y_pred)和y_target来计算损失</p></li><li><p>PyTorch损失对象(criteria)具有一个名为backward()的函数，该函数迭代地通过计算图向后传播损失，并将梯度通知给每个参数</p></li><li><p>最后，优化器(optim)用一个名为step()的函数指示参数如何在已知梯度的情况下更新参数</p><p>至此，完成了一次参数的更新。</p></li></ul><h3 id="Correctly-Measuring-Model-Performance-Splitting-the-Dataset"><a href="#Correctly-Measuring-Model-Performance-Splitting-the-Dataset" class="headerlink" title="Correctly Measuring Model Performance:Splitting the Dataset"></a>Correctly Measuring Model Performance:Splitting the Dataset</h3><p>​    我们训练模型的最终目标是使模型能够很好的概括数据的真实分布。然而数据有限，所以其实数据的真实分布是不得而知的。因此当模型过度拟合训练数据的分布时，因为训练数据不能够代表全部数据的真实分布，这个时候就会产生过拟合。</p><p>​    如何避免过拟合(顺便提一嘴)：</p><ul><li>增加训练数据</li><li>降维</li><li>正则化</li></ul><p>​    如何选择模型：</p><ul><li>在训练数据比较充足时，可以将训练数据划分为训练集、验证集和测试集</li><li>大多数情况下，训练数据没有那么充裕，这个时候可以使用交叉验证</li></ul><h3 id="Knowing-When-to-Stop-Training"><a href="#Knowing-When-to-Stop-Training" class="headerlink" title="Knowing When to Stop Training"></a>Knowing When to Stop Training</h3><ul><li>选择模型训练的epoch数目一般使用启发式发放，一般称为早停止<ul><li>在每个epoch或每N个epoch结束后，查看模型在验证集上的结果，如果验证集准确率要高于之前的模型，则保留当前训练的模型副本，否则停止训练</li><li>将测试性能最优的模型作为最后的训练结果</li></ul></li></ul><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><ul><li>L2正则化<ul><li>在pytorch中，可以通过在优化器(optim)中设置weight_decay参数来控制正则化的程度</li></ul></li><li>结构正则化技术<ul><li>Dropout</li></ul></li><li>L1正则化<ul><li>鼓励稀疏解</li></ul></li></ul><h2 id="Example：Classifying-Sentiment-of-Restaurant-Reviews"><a href="#Example：Classifying-Sentiment-of-Restaurant-Reviews" class="headerlink" title="Example：Classifying Sentiment of Restaurant Reviews"></a>Example：Classifying Sentiment of Restaurant Reviews</h2><h3 id="The-Yelp-Review-Dataset"><a href="#The-Yelp-Review-Dataset" class="headerlink" title="The Yelp Review Dataset"></a>The Yelp Review Dataset</h3><p>​    Yelp评论数据集最初是2015年由Yelp(美国最大的点评网站)举办的文本情感分类比赛中提出的，其中有56万个训练样本和3.8万个测试样本。在这里是选择了10%的训练数据作为完整数据集。</p><p>​    <font color="#0099ff">使用一个小数据集可以快速进行试验，可以使用从较小数据集子集中获得的知识对整个数据集进行重新训练。在训练深度学习模型时，这是一个非常有用的技巧。</font></p><ul><li>通过训练集来得到模型的参数</li><li>通过验证集选择最优的超参数</li><li>通过测试集对模型进行最终的评估和报告</li></ul><p>​    在几乎每个实例中， 都使用Vocabulary，Vectorizer和Dataset这三个类来执行一个关键的pipeline：将文本输入转化为小批量的向量。</p><h3 id="Understanding-PyTorch’s-Dataset-Representation"><a href="#Understanding-PyTorch’s-Dataset-Representation" class="headerlink" title="Understanding PyTorch’s Dataset Representation"></a>Understanding PyTorch’s Dataset Representation</h3><p>​    PyTorch通过提供 class Dataset为数据集提供了一个抽象，在对新数据集使用PyTorch时，新的数据集类必须继承Dataset类，并实现<strong>getitem</strong>和<strong>len</strong>方法。</p><p>​    通过针对每个实际的数据集实现继承PyTorch的新的数据集类，允许各种PyTorch程序使用新实现的数据集类。</p><p>​    ReviewDataset Class的结构：</p><ul><li>__init__()<ul><li>重写构造函数，为各种变量赋值<ul><li>self.review_df - 数据集(什么样的数据集？)</li><li>self._vectorizer - 向量化的数据集</li><li>训练集、验证集、测试集变量</li><li>其他</li></ul></li></ul></li><li><font color="#ff0000">@classmethod</font> load_dataset_and_make_vectorizer()<ul><li>加载数据集并创建向量化的实例</li><li><font color="#ff0000">@classmethod</font> 是类的内置函数，它能够自己创建一个类的实例</li></ul></li><li><font color="#ff0000">@classmethod</font> load_dataset_and_load_vectorizer()<ul><li>加载数据集和向量化的实例</li><li><font color="#ff0000">@classmethod</font> 这两个内置函数实际上完成了两个任务<ul><li>在没有正确格式的数据集和向量时先对数据进行格式化</li><li>然后再创建Dataset的实例</li></ul></li></ul></li><li><font color="#ff0000">@staticmethod</font> load_vectorizer_only()<ul><li>仅加载向量</li></ul></li><li>save_vectorizer()<ul><li>将向量化的实例使用json存储到硬盘</li></ul></li><li>get_vectorizer()<ul><li>返回向量(仅仅是将类的属性返回)</li></ul></li><li>get_split()<ul><li>选择将要处理的数据，并给类的对应属性赋值</li></ul></li><li>__len__(self)<ul><li>返回要处理数据的size</li></ul></li><li>__getitem__()<ul><li>重写的PyTorch的Dataset类的方法</li><li>暂时没看明白是干什么的》。。。</li></ul></li><li>get_num_batcher()<ul><li>输入批的大小，返回批的数量</li></ul></li></ul><h3 id="The-Vocabulary-the-Vectorizer-and-the-DataLoader"><a href="#The-Vocabulary-the-Vectorizer-and-the-DataLoader" class="headerlink" title="The Vocabulary, the Vectorizer, and the DataLoader"></a>The Vocabulary, the Vectorizer, and the DataLoader</h3><h4 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h4><p>​    从文本到向量化的minibatch处理的第一步是将每个token映射到它的向量标号。实现方法是在token和标号之间有一个双向映射。这两个映射被封装到Vocabulary中。</p><p>​    Vocabulary类的结构如下：</p><ul><li>__init()__<ul><li>self._token_to_idx 一个完成从token到ID的映射的字典</li><li>self._idx_to_token 完成从id到token的映射</li></ul></li><li>to_serializable()<ul><li>返回一个可以被序列化的字典</li></ul></li><li><font color="#ff0000">@classmethod</font> from_serializable()<ul><li>从一个序列化的字典(to_serializable返回的对象)中创建Vocabulary实例</li></ul></li><li>add_token()<ul><li>根据token更改两个映射字典</li></ul></li><li>add_many()<ul><li>添加许多个token到Vocabulary中</li></ul></li><li>lookup_token()<ul><li>查找token的index，如果token没出现，就返回UNK的index</li></ul></li><li>lookup_index()<ul><li>查找index对应的token</li></ul></li><li>__str__()<ul><li>返回self的大小(?)</li></ul></li><li>__len__()<ul><li>返回映射的大小</li></ul></li></ul><h4 id="Vectorizer"><a href="#Vectorizer" class="headerlink" title="Vectorizer"></a>Vectorizer</h4><p>​    ReviewVectorizer()的结构：</p><ul><li>__init__()<ul><li>self.review_vocab 将词(word)与整数匹配</li><li>self.rating_vocab 将类别标签与整数匹配</li></ul></li><li>vectorize()<ul><li>创建一个review的one-hot向量</li></ul></li><li><font color="#ff0000">@classmethod</font> form_dataframe()<ul><li>从Dataset 的dataframe结构实例化向量(?究竟干了啥)</li><li>创建了一个一样的向量</li></ul></li><li><font color="#ff0000">@classmethod</font> from_serializable()<ul><li>从serializable dictionary 创建一个评论向量</li></ul></li><li>to_serializable()<ul><li>Create the serializable dictionary for caching</li></ul></li></ul><h4 id="Dataloader"><a href="#Dataloader" class="headerlink" title="Dataloader"></a>Dataloader</h4><p>​    文本向量化小批处理的最后一个阶段是对向量化的数据分组。PyTorch提供了一个名为DataLoader的内置类来协调这个过程。DataLoader通过提供一个PyTorch数据集、一个batch_size和一些关键字参数来实例化，得到的对象是一个python迭代器。</p><p>​    本例中，通过在定义函数generate_batcher()中使用DataLoader内置类，来实现batch的迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_batches</span><span class="params">(dataset, batch_size, shuffle=True, drop_last=True, device=<span class="string">"cpu"</span>)</span>:</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="A-Percptron-Classifier"><a href="#A-Percptron-Classifier" class="headerlink" title="A Percptron Classifier"></a>A Percptron Classifier</h3><p>​    定义一个ReviewClassifier类，来实现计算模型的预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewClassifier</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h3 id="The-Training-Routine"><a href="#The-Training-Routine" class="headerlink" title="The Training Routine"></a>The Training Routine</h3><p>​    这里的训练模型的历程可以看做一种规范，在深度学习的开发中，可以将这看做一种习惯。</p><p>​    使用python内置的argparse模块来进行参数的管理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> Namespace</span><br><span class="line"></span><br><span class="line">args = Namespace(......)</span><br></pre></td></tr></table></figure><h4 id="Setting-The-Stage-For-The-Training-To-Begin"><a href="#Setting-The-Stage-For-The-Training-To-Begin" class="headerlink" title="Setting The Stage For The Training To Begin"></a>Setting The Stage For The Training To Begin</h4><ul><li>初始训练状态</li><li>实例化数据集和模型</li><li>实例化损失函数和优化器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_train_state</span><span class="params">(args)</span>:</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">train_state = make_train_state(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset and vectorizer</span></span><br><span class="line">dataset = ReviewDataset.load_dataset_and_make_vectorizer(arts.review_csv)</span><br><span class="line">vectorizer = data.get_vectorizer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># model,仅仅给出预测</span></span><br><span class="line">classifier =  ReviewClassifier(num_features = len(vectorizer.review_vocab))</span><br><span class="line">classifier = classifier.to(args.device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss and optimizer， 计算损失并进行优化</span></span><br><span class="line">loss_func = nn.BCEWithLogitsLoss()</span><br><span class="line">optimizer = optim.Adam(classifier.parameters(), lr=args.learning_rate)</span><br></pre></td></tr></table></figure><h4 id="The-Training-Loop"><a href="#The-Training-Loop" class="headerlink" title="The Training Loop"></a>The Training Loop</h4><p>​    训练循环由两个循环组成：内循环覆盖数据集中的mini-batch，另一个外循环重复内循环若干次。在每个内部循环中，计算损失，并使用优化器更新模型参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch_index <span class="keyword">in</span> range(args.num_epoch):</span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    <span class="keyword">for</span> batch_index, batch_dict <span class="keyword">in</span> enumerate(batch_generator):</span><br><span class="line">        <span class="comment"># 1. zero the gradients</span></span><br><span class="line">        <span class="comment"># 2. compute the output</span></span><br><span class="line">        <span class="comment"># 3. compute the loss</span></span><br><span class="line">        <span class="comment"># 4. use loss to produce gradients</span></span><br><span class="line">        <span class="comment"># 5. use optimizer to take gradient step</span></span><br><span class="line">        <span class="comment"># compute the accuracy</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 在训练完每个epoch之后在计算模型在验证集上的准确率，从而判断是否发生了过拟合</span></span><br><span class="line">    <span class="keyword">for</span> batch_index, batch_dict <span class="keyword">in</span> enumerate(batch_generator):</span><br><span class="line">        <span class="comment"># 1. compute the output</span></span><br><span class="line">        <span class="comment"># 2. compute the loss</span></span><br><span class="line">        <span class="comment"># 3. compute the accuracy</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 结束一个epoch的训练过程，中间过程的结果都被保存到了train_state中</span></span><br></pre></td></tr></table></figure><h3 id="Evaluation-Inference-and-Inspection"><a href="#Evaluation-Inference-and-Inspection" class="headerlink" title="Evaluation, Inference, and Inspection"></a>Evaluation, Inference, and Inspection</h3><h4 id="Evaluation-Inference-and-Inspection-1"><a href="#Evaluation-Inference-and-Inspection-1" class="headerlink" title="Evaluation, Inference, and Inspection"></a>Evaluation, Inference, and Inspection</h4><p>​    在测试集上进行验证的过程与在验证集上进行计算的过程完全相同。</p><h4 id="Inference-And-Classifying-New-Data-Points"><a href="#Inference-And-Classifying-New-Data-Points" class="headerlink" title="Inference And Classifying New Data Points"></a>Inference And Classifying New Data Points</h4><p>​    在新数据上进行推断，看模型效果如何。</p><h4 id="Inspecting-Model-Weights"><a href="#Inspecting-Model-Weights" class="headerlink" title="Inspecting Model Weights"></a>Inspecting Model Weights</h4><p>​    另一种检查模型在完成训练后是否表现良好的方法是检查权重，对权重是否正确做出判断。</p><p>​    对当前的这个任务来说这种方法是可行的，但是并不通用。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-3-神经网络基础组件&quot;&gt;&lt;a href=&quot;#Chapter-3-神经网络基础组件&quot; class=&quot;headerlink&quot; title=&quot;Chapter 3.神经网络基础组件&quot;&gt;&lt;/a&gt;Chapter 3.神经网络基础组件&lt;/h1&gt;&lt;h2 id=&quot;P
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="深度学习框架" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PyTorch" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/PyTorch/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="PyTorch" scheme="http://yyukachiiii.github.io/child/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>对话系统</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/09/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E8%AF%9D/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/09/论文阅读/人机对话/</id>
    <published>2019-09-09T04:24:20.000Z</published>
    <updated>2019-09-09T06:49:20.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人机对话系统综述，2018，哈工大"><a href="#人机对话系统综述，2018，哈工大" class="headerlink" title="人机对话系统综述，2018，哈工大"></a>人机对话系统综述，2018，哈工大</h1><h2 id="人机对话系统的研究背景及意义"><a href="#人机对话系统的研究背景及意义" class="headerlink" title="人机对话系统的研究背景及意义"></a>人机对话系统的研究背景及意义</h2><p>​    人机对话系统的研究最早追溯到1950年，即图灵测试。测试者借助某种装置已对话的方式与人类或对话系统进行交谈，当测试结束后，如果有30%以上的测试者不能正确区分对话系统和人的回复，则称该系统通过了图灵测试，拥有了人的智能。</p><p>​    人机对话系统的功能分类：</p><ul><li>任务型<ul><li>目的：完成特定任务</li><li>应用场景：虚拟个人助理</li></ul></li><li>开放域聊天<ul><li>目的：闲聊</li><li>应用场景：娱乐、情感陪护、营销沟通</li></ul></li><li>知识问答<ul><li>目的：知识获取</li><li>应用场景：客服、教育</li></ul></li><li>推荐<ul><li>目的：信息推荐</li><li>应用场景：个性化推荐</li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ul><li>最早的人机对话系统：诞生于1966年，由MIT的Joseph Weizenbaum开发的ELIZA<ul><li>作用：用于在临床治疗中模仿心理医生</li></ul></li><li>1988年，UC Berkeley开发了名为UC(UNIX Consultant)的对话系统<ul><li>作用：帮助用户学习怎样使用UNIX操作系统</li><li>地位：推动了对话系统的智能化程度</li></ul></li><li>Richard S. Wallace在1995年开发了ALICE系统，并与1998年开源</li></ul><h2 id="模型和框架"><a href="#模型和框架" class="headerlink" title="模型和框架"></a>模型和框架</h2><p>​    一般的人机对话系统通常包括三个关键模块：</p><ul><li>口语语言理解(SLU):将用户说出的话转换为结构化的语义表示。<ul><li>举例：识别出“领域、意图和语义槽(slot)”</li></ul></li><li>对话管理(DM)<ul><li>定义：综合用户当前输入和历史对话中已获得的信息，给出机器答复的结构化表示。</li><li>结构<ul><li>对话状态追踪(Dialogue State Tracking, DST)<ul><li>作用：依据SLU的结果，把旧的对话状态更新为新的对话状态</li></ul></li><li>对话策略优化(Dialogue Policy Optimization, DPO)<ul><li>作用：根据DST维护的对话状态，确定当前状态下如何回复</li></ul></li></ul></li></ul></li><li>自然语言生成(NLG)<ul><li>定义：把DM输出的结构化对话策略还原成对人友好的自然语言</li></ul></li></ul><h2 id="实现技术和方案"><a href="#实现技术和方案" class="headerlink" title="实现技术和方案"></a>实现技术和方案</h2><p>​    以上框架是针对任务型对话系统提出的，并不能够很好的应对开放域聊天型对话系统。因为在开放领域中，无法穷举用户的意图和语义槽，也无法穷举可能的回复策略。</p><p>​    但随着深度学习技术的发展，用户的意图和回复策略等信息可以使用向量隐式的表示。而且可以自动的从大量的对话数据中学习出来。</p><p>​    任务型和开放域聊天机器人不同模块的对比：</p><ul><li>任务型机器人<ul><li>对话语言理解<ul><li>领域及意图识别、语义槽识别</li></ul></li><li>对话管理<ul><li>状态跟踪、对话策略</li></ul></li><li>自然语言生成<ul><li>基于模板(穷举)</li></ul></li></ul></li><li>开放域聊天<ul><li>对话语言理解<ul><li>主题识别、关键词识别、情感分析</li></ul></li><li>对话管理<ul><li>记忆网络、对话上下文建模</li></ul></li><li>自然语言生成<ul><li>基于深度学习的编码-解码</li></ul></li></ul></li></ul><p>​    当前研究热点：</p><ul><li>使用深度学习技术实现任务型对话的各个模块</li><li>使用端到端技术直接生成自然语言回复</li><li>结合外部知识库进行自然语言生成</li></ul><h2 id="服务平台"><a href="#服务平台" class="headerlink" title="服务平台"></a>服务平台</h2><p>​    开发一个对话系统的步骤：</p><ul><li>定义和准备<ul><li>定义该对话系统支持的领域/意图和问题类型</li><li>定义语义槽</li><li>进行相关的数据标注</li></ul></li><li>训练和实现<ul><li>训练领域/意图或问题分类模型</li><li>实现语言理解、对话管理和语言生成模块</li></ul></li><li>部署<ul><li>在自己的服务器上，部署实现好的工程，对用户提供服务</li></ul></li></ul><h2 id="总结及展望"><a href="#总结及展望" class="headerlink" title="总结及展望"></a>总结及展望</h2><p>​    当前的人机对话系统的主要问题：</p><ul><li>在聊天上如何让机器更像人</li><li>在场景化任务中如何做到高效的场景切换</li></ul><h6 id="基于多轮交互的人机对话系统综述，2019，中科大"><a href="#基于多轮交互的人机对话系统综述，2019，中科大" class="headerlink" title="基于多轮交互的人机对话系统综述，2019，中科大"></a>基于多轮交互的人机对话系统综述，2019，中科大</h6><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>单轮对话一般不存在指代省略或上下文连贯性问题</li><li>多轮对话中存在人机的多轮交互，对聊天的上下文、指代省略的补全和复杂需求的明确的等问题都有更为复杂的要求</li><li>早期的对话系统的研究，基本都是采用基于符号和规则的方法，至今仍然是主流的人机对话系统的解决方案之一</li></ul><h2 id="基于多轮交互的人机对话系统主要类型及解决方案"><a href="#基于多轮交互的人机对话系统主要类型及解决方案" class="headerlink" title="基于多轮交互的人机对话系统主要类型及解决方案"></a>基于多轮交互的人机对话系统主要类型及解决方案</h2><h3 id="任务型对话"><a href="#任务型对话" class="headerlink" title="任务型对话"></a>任务型对话</h3><h4 id="基于管道的方法"><a href="#基于管道的方法" class="headerlink" title="基于管道的方法"></a>基于管道的方法</h4><p>​    任务型对话的一种经典的解决方案，主要结构包括：</p><ul><li>自然语言理解</li><li>对话管理<ul><li>对话状态追踪</li><li>对话策略学习</li></ul></li><li>自然语言生成</li></ul><h5 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h5><ul><li>输入：用户的语句</li><li>任务<ul><li>槽标记(slot tagging)<ul><li>对句子中的语义槽序列进行标记</li><li>语义槽是根据不同的场景预先定义的</li><li>大量基于深度神经网络的方法被应用到这个问题上</li></ul></li><li>领域识别(domain detection)<ul><li>将用户的服务需求划分到某一事先定义好的领域下</li></ul></li><li>意图理解(intent determination)<ul><li>针对用户的表述中的显示意图和隐示意图做出识别和理解</li></ul></li></ul></li><li>地位<ul><li>对话系统中的预处理模块</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人机对话系统综述，2018，哈工大&quot;&gt;&lt;a href=&quot;#人机对话系统综述，2018，哈工大&quot; class=&quot;headerlink&quot; title=&quot;人机对话系统综述，2018，哈工大&quot;&gt;&lt;/a&gt;人机对话系统综述，2018，哈工大&lt;/h1&gt;&lt;h2 id=&quot;人机对话系
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="对话系统" scheme="http://yyukachiiii.github.io/child/tags/%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>文本摘要论文阅读</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/08/论文阅读/文本摘要/</id>
    <published>2019-09-08T11:43:45.000Z</published>
    <updated>2019-09-09T02:48:54.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学"><a href="#文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学" class="headerlink" title="文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学"></a>文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>任务目的<ul><li>从一篇或多篇主题相同的文本中抽取能够反映主题的精简压缩版本，帮助用户快速形成对特定主题文本内容的全面了解</li></ul></li><li>任务分类<ul><li>输入文本数量<ul><li>单文本摘要方法</li><li>多文本摘要方法</li></ul></li><li>抽取方式<ul><li>抽取式摘要<ul><li>从原文中不加修改的抽取文本片段组成摘要</li></ul></li><li>生成式摘要<ul><li>重新组织句子形成比抽取式摘要更加精简的形式</li></ul></li></ul></li><li>摘要目标<ul><li>面向查询的摘要(阅读理解？问答？)</li><li>一般总结性摘要</li></ul></li><li>领域需求<ul><li>医学摘要</li><li>邮件摘要</li><li>……</li></ul></li></ul></li><li>文章内容总结<ul><li>常用数据集总结</li><li>做针对数据集的方法总结和分析</li><li>总结常用数据集和方法的研究现状、存在的问题</li></ul></li></ul><h2 id="文本摘要常用数据集总体概况"><a href="#文本摘要常用数据集总体概况" class="headerlink" title="文本摘要常用数据集总体概况"></a>文本摘要常用数据集总体概况</h2><p>​    文本摘要常用数据集大致可分为两类：</p><ul><li>公用数据集</li><li>自建数据集</li></ul><p>​    基于深度神经网络的文本摘要需要较大规模(十万级规模)的训练数据。</p><h2 id="DUC-TAC"><a href="#DUC-TAC" class="headerlink" title="DUC/TAC"></a>DUC/TAC</h2><ul><li>描述<ul><li>人工标注的生成式摘要数据集</li><li>规模较小(百篇规模),不适用于训练深度神经网络模型</li></ul></li><li>主要方法<ul><li>基于图模型的方法</li><li>基于传统机器学习的方法</li></ul></li></ul><h2 id="Gigaword"><a href="#Gigaword" class="headerlink" title="Gigaword"></a>Gigaword</h2><ul><li>描述<ul><li>由英文新闻文章组成的数据集，包括950万多个新闻源的新闻语料</li></ul></li><li>生成方式<ul><li>将文章的首句话与新闻提要组成生成式摘要语料库</li></ul></li><li>特点<ul><li>原句与摘要句都是单个句子</li></ul></li></ul><h2 id="CNN-Daily-Mail"><a href="#CNN-Daily-Mail" class="headerlink" title="CNN/Daily Mail"></a>CNN/Daily Mail</h2><ul><li>描述<ul><li>单文本摘要语料库</li><li>每篇摘要包含多个摘要句</li></ul></li></ul><h2 id="LCSTS-Large-scale-Chinese-Short-Text-Summatization-dataset"><a href="#LCSTS-Large-scale-Chinese-Short-Text-Summatization-dataset" class="headerlink" title="LCSTS(Large scale Chinese Short Text Summatization dataset)"></a>LCSTS(Large scale Chinese Short Text Summatization dataset)</h2><ul><li>描述<ul><li>短文本新闻摘要数据库</li></ul></li><li>来源<ul><li>新浪微博</li></ul></li><li>规模<ul><li>超过200万</li></ul></li><li>特点<ul><li>文本篇幅较短</li><li>存在噪声</li></ul></li><li>以提出的方法<ul><li>利用RNN提取生成式摘要</li><li>注意力机制</li></ul></li></ul><h2 id="NLPCC-自然语言处理与中文计算会议"><a href="#NLPCC-自然语言处理与中文计算会议" class="headerlink" title="NLPCC(自然语言处理与中文计算会议)"></a>NLPCC(自然语言处理与中文计算会议)</h2><ul><li>背景<ul><li>NLPCC是由CCF举办的自然语言文本评测会议，包括文本摘要、情感分析、自动问答等任务</li><li>在NLPCC出现的文本摘要任务均为单文本摘要</li></ul></li><li>特点<ul><li>新闻文本不分领域、不分类型</li><li>篇幅较长</li></ul></li><li>已有方法<ul><li>。。。</li></ul></li></ul><h2 id="自建数据集及其对应方法"><a href="#自建数据集及其对应方法" class="headerlink" title="自建数据集及其对应方法"></a>自建数据集及其对应方法</h2><p>​    公用数据集较少，因此基于自建数据集的摘要任务，常用方法可分为：</p><ul><li>基于统计的方法</li><li>基于图模型的方法</li><li>基于词法链的方法</li><li>基于篇章结构的方法</li><li>基于机器学习的方法</li></ul><h2 id="经典算法和最新方法用到的数据集"><a href="#经典算法和最新方法用到的数据集" class="headerlink" title="经典算法和最新方法用到的数据集"></a>经典算法和最新方法用到的数据集</h2><p>​    经典方法和最新方法大都是基于深度学习的方法，但是也包括LexRank、TextRank等经典方法。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>缺少大规模中文长文本数据集</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学&quot;&gt;&lt;a href=&quot;#文本摘要常用数据集和方法研究综述，2019，中科院，中科院大学&quot; class=&quot;headerlink&quot; title=&quot;文本摘要常用数据集和方法研究综述，2019，中科院，中科院大
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="文本摘要" scheme="http://yyukachiiii.github.io/child/tags/%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>阅读理解论文阅读</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/08/论文阅读/阅读理解/</id>
    <published>2019-09-08T08:19:55.000Z</published>
    <updated>2019-09-09T02:49:11.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于深度学习的机器阅读理解综述，2019，北航"><a href="#基于深度学习的机器阅读理解综述，2019，北航" class="headerlink" title="基于深度学习的机器阅读理解综述，2019，北航"></a>基于深度学习的机器阅读理解综述，2019，北航</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>定义<ul><li>让机器学会阅读和理解文章，对于给定的问题，从相关文章中寻找答案</li></ul></li><li>设计技术<ul><li>语言理解</li><li>知识推理</li><li>摘要生成</li></ul></li><li>应用<ul><li>智能搜索：搜索互联网的文档进行阅读理解，为用户返回更加准确和智能的答案</li><li>智能客服</li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ul><li>1999年开始了最早的MRC研究</li><li>传统的MRC技术大多采用模式匹配的方法进行特征提取，不能处理表达的多样性问题</li><li>先进的MRC技术采用深度神经网络进行机器阅读理解的研究</li><li>2016年斯坦福发布大规模数据集SQuAD，极大推动了MRC的快速发展</li><li>总结：<ul><li>历史比较短，研究内容都比较新</li></ul></li></ul><h2 id="基于深度学习的阅读理解"><a href="#基于深度学习的阅读理解" class="headerlink" title="基于深度学习的阅读理解"></a>基于深度学习的阅读理解</h2><ul><li>模型的组成<ul><li>词向量模块<ul><li>将所有单词映射到一个向量空间，包含单词的语法和语义信息，及词与词之间的关系</li></ul></li><li>编码模块<ul><li>以词向量表示的文本序列作为输入，通过深度神经网络对文本序列进行特征提取，含有上行下文信息和语义信息</li></ul></li><li>注意力模块<ul><li>从文章中挑选出与问题关联度最大的部分内容，排除不相关信息</li></ul></li><li>答案预测模块<ul><li>方法由抽取式逐渐发展为生成式；由单篇文章提供转向多篇文章生成</li></ul></li></ul></li></ul><h3 id="词向量模块"><a href="#词向量模块" class="headerlink" title="词向量模块"></a>词向量模块</h3><p>​    词向量的生成方式：</p><ul><li>矩阵分解法</li><li>参数学习法</li><li>上下文学习法</li></ul><h4 id="参数学习法"><a href="#参数学习法" class="headerlink" title="参数学习法"></a>参数学习法</h4><p>​    常见的参数学习法：</p><ul><li>Bengio等基于神经网络的概率语言模型，将词向量作为语言模型的参数进行学习</li><li>Mikolov提出的Word2vec模型，借鉴N-gram思想，没有考虑全局信息</li></ul><p>​    缺陷：</p><ul><li>没有解决一词多义的问题</li></ul><h4 id="上下文学习法"><a href="#上下文学习法" class="headerlink" title="上下文学习法"></a>上下文学习法</h4><ul><li>参数学习法是词向量的一种静态的表示方法，同一个词汇具有相同的词向量表示</li><li>解决一词多义问题关键在于利用上下文语境，词向量是动态的模型输出</li></ul><p>​    上下文学习法学习到的词向量举例：</p><ul><li>BiLSTM</li><li>ELMo(Embeddings from Language Models)</li></ul><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>​    处理阅读理解问题时，基于神经网络的模型几乎都使用了注意力机制。</p><p>​    在MRC中，根据注意力机制的结构，可分为：</p><ul><li>单路注意力模型</li><li>双路注意力模型</li><li>自匹配注意力模型</li></ul><h4 id="单路注意力模型"><a href="#单路注意力模型" class="headerlink" title="单路注意力模型"></a>单路注意力模型</h4><ul><li>描述：<ul><li>模拟人做阅读理解的过程</li><li>只在文章上使用注意力机制</li><li>通过结合问题和文本段落二者的信息，生成一个关于文本段落各部分的注意力权重，对文本信息进行加权</li></ul></li></ul><h4 id="双路注意力模型"><a href="#双路注意力模型" class="headerlink" title="双路注意力模型"></a>双路注意力模型</h4><ul><li>描述：<ul><li>同时在问题和文章上使用注意力机制</li><li>对文章和问题之间进行了细粒度的建模，一般比单路注意力模型好</li></ul></li></ul><h4 id="自匹配注意力模型"><a href="#自匹配注意力模型" class="headerlink" title="自匹配注意力模型"></a>自匹配注意力模型</h4><ul><li>描述<ul><li>反复阅读文章并找出重点</li></ul></li><li>注意力模块是机器阅读理解的核心模块，对提升模型的性能至关重要</li></ul><h3 id="答案预测"><a href="#答案预测" class="headerlink" title="答案预测"></a>答案预测</h3><p>​    主要分类：</p><ul><li>抽取式</li><li>生成式</li></ul><h4 id="答案抽取"><a href="#答案抽取" class="headerlink" title="答案抽取"></a>答案抽取</h4><ul><li>定义<ul><li>从文章中挑取答案，然后生成答案</li></ul></li><li>举例<ul><li>斯坦福大学的SQuAD数据集中，每个问题的答案都是原文的一个子片段，是典型的抽取式数据集</li></ul></li><li>抽取模型<ul><li>序列模型</li><li>边界模型</li></ul></li></ul><h4 id="答案生成"><a href="#答案生成" class="headerlink" title="答案生成"></a>答案生成</h4><ul><li>举例<ul><li>微软亚洲研究院的MS MARCO数据集，答案是人工阅读候选文章后总结生成的，不再受限于文章片段，要求模型具有生成答案的能力</li></ul></li><li>实例<ul><li>通过答案抽取模型从候选文章中提取线索，然后用机器翻译模型将线索翻译为答案</li></ul></li><li>现状<ul><li>抽取模型仍是主流，生成技术只是作为一种辅助手段产生答案</li></ul></li></ul><h2 id="MRC面临的主要问题"><a href="#MRC面临的主要问题" class="headerlink" title="MRC面临的主要问题"></a>MRC面临的主要问题</h2><h3 id="词向量模块仍需改善"><a href="#词向量模块仍需改善" class="headerlink" title="词向量模块仍需改善"></a>词向量模块仍需改善</h3><ul><li>使用预训练的语言模型取代预训练的词向量对MRC模型带来了显著的提升</li><li>但基于语言模型的词向量仍然有局限性</li></ul><h3 id="模型缺乏推理能力"><a href="#模型缺乏推理能力" class="headerlink" title="模型缺乏推理能力"></a>模型缺乏推理能力</h3><ul><li>当前的阅读理解模型仍不具备推理能力，而是注意某些线索以执行粗浅的模式匹配</li></ul><h3 id="模型缺乏外部知识"><a href="#模型缺乏外部知识" class="headerlink" title="模型缺乏外部知识"></a>模型缺乏外部知识</h3><ul><li>模型的信息均来自于文章，没有结合外部知识</li></ul><h3 id="答案生成技术研究不足"><a href="#答案生成技术研究不足" class="headerlink" title="答案生成技术研究不足"></a>答案生成技术研究不足</h3><ul><li>当前的答案生成技术仍然以抽取式为主，因此在SQuAD数据集上取得了成功</li><li>但是在MS MACRO等贴近真实应用场景的数据集仍效果欠佳</li></ul><h2 id="MRC的发展趋势"><a href="#MRC的发展趋势" class="headerlink" title="MRC的发展趋势"></a>MRC的发展趋势</h2><ul><li>构建端到端的高效模型</li><li>深层结构探索，提高推理能力</li><li>与其他NLP技术进行结合<ul><li>外部知识库</li><li>指代消解</li></ul></li><li>答案生成技术的深入研究</li><li>对多候选文章进行排名</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>什么是预训练语言模型？</li><li>最新的SQuAD数据集由500+文章和10,0000+问题组成，训练集20MB左右，发展集4MB左右，仅训练数据来看并不大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于深度学习的机器阅读理解综述，2019，北航&quot;&gt;&lt;a href=&quot;#基于深度学习的机器阅读理解综述，2019，北航&quot; class=&quot;headerlink&quot; title=&quot;基于深度学习的机器阅读理解综述，2019，北航&quot;&gt;&lt;/a&gt;基于深度学习的机器阅读理解综述，2
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="阅读理解" scheme="http://yyukachiiii.github.io/child/tags/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>自动问答论文阅读</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E8%87%AA%E5%8A%A8%E9%97%AE%E7%AD%94/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/08/论文阅读/自动问答/</id>
    <published>2019-09-08T07:07:34.000Z</published>
    <updated>2019-09-09T02:49:23.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动问答综述，2002，哈尔滨工业大学"><a href="#自动问答综述，2002，哈尔滨工业大学" class="headerlink" title="自动问答综述，2002，哈尔滨工业大学"></a>自动问答综述，2002，哈尔滨工业大学</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>传统的搜索引擎的不足<ul><li>相关性信息太多</li><li>检索需求无法以几个关键字的逻辑组合来完全表达</li><li>以关键字为基础的索引停留的语言层面，没有涉及到语义</li></ul></li><li>自动问答系统<ul><li>为了改进搜索引擎的弊端发展而来</li><li>问答系统就是新一代的搜索引擎</li></ul></li></ul><h2 id="研究概况"><a href="#研究概况" class="headerlink" title="研究概况"></a>研究概况</h2><ul><li>早起(上世纪80年代)的问答系统一直被限制在特殊领域的专家系统</li><li>组成(三个部分)：<ul><li>问题分析：理解用户的问题是什么<ul><li>问题分类</li><li>关键词提取</li><li>关键词扩展</li></ul></li><li>信息检索：在已有的文档中查找和关键词集相关的文档</li><li>答案抽取：从信息检索中返回的网页中抽取答案<ul><li>最为影响整个问答系统准确性的部分</li></ul></li><li>常问问题(FAQ)库：常问问题可以直接从库中检索并返回</li></ul></li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>​    需要完成的任务：</p><ul><li>确定问题的类型</li><li>提取出问题的关键词</li><li>依据问题的类型对关键词进行适当的扩展</li></ul><h3 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h3><p>​    针对不同类型的问题，有不同的处理方法，例如询问人、询问时间、询问数量等等。</p><p>​    对问题分类之后，在针对不同的问题类型，制定不同的答案抽取规则。</p><p>​    问题分类有两种方法：</p><ul><li>按照事先规定好的类别进行分类</li><li>使用机器学习算法自动分类</li></ul><h3 id="关键词提取"><a href="#关键词提取" class="headerlink" title="关键词提取"></a>关键词提取</h3><p>​    在问题中，提取出对检索有用的关键字。关键词能够提高检索系统的准确性。</p><h3 id="关键词扩展"><a href="#关键词扩展" class="headerlink" title="关键词扩展"></a>关键词扩展</h3><p>​    答案中的词常常不是问题的关键词，而是关键词的同义扩展。</p><p>​    关键词扩展虽然能够提高系统的召回率，但是扩展不当却会降低检索的正确率。</p><h2 id="信息检索模块"><a href="#信息检索模块" class="headerlink" title="信息检索模块"></a>信息检索模块</h2><ul><li>任务<ul><li>用前面提取出的关键字到文档库中查找相关的文档</li></ul></li><li>信息检索模块的建立<ul><li>对文档库进行预处理(汉语要分词、英语要Stemming)</li><li>对文档库建立索引</li></ul></li><li>返回内容<ul><li>文档、段落或句子</li></ul></li></ul><h2 id="答案抽取"><a href="#答案抽取" class="headerlink" title="答案抽取"></a>答案抽取</h2><ul><li>任务<ul><li>将信息检索模块搜索出来的相关文档抽取答案</li></ul></li></ul><h3 id="以句子作为答案"><a href="#以句子作为答案" class="headerlink" title="以句子作为答案"></a>以句子作为答案</h3><p>​    步骤如下：<font color="#19caad"><strong>（类似于文本摘要呀）</strong></font></p><ul><li>把检索出来的文档分成句子</li><li>按照一定的算法，计算每个句子的权重</li><li>对句子按照权重进行排序</li><li>根据问题的类型对候选答案重新排序</li></ul><h3 id="以词或短语作为答案"><a href="#以词或短语作为答案" class="headerlink" title="以词或短语作为答案"></a>以词或短语作为答案</h3><h3 id="以文摘作为答案"><a href="#以文摘作为答案" class="headerlink" title="以文摘作为答案"></a>以文摘作为答案</h3><p>​    多文档自动摘要技术，把相关文档做成文摘，在把文摘返回给用户。</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>​    建立测试集，将系统对测试集问题得到的回答与人工答案进行对比，计算出问答系统的准确率。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p> 当前(2002年)的问答系统不具备思维和推论能力，只是从文档库中搜索相关的答案。自动问答技术处于起步阶段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自动问答综述，2002，哈尔滨工业大学&quot;&gt;&lt;a href=&quot;#自动问答综述，2002，哈尔滨工业大学&quot; class=&quot;headerlink&quot; title=&quot;自动问答综述，2002，哈尔滨工业大学&quot;&gt;&lt;/a&gt;自动问答综述，2002，哈尔滨工业大学&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="论文阅读" scheme="http://yyukachiiii.github.io/child/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="问答系统" scheme="http://yyukachiiii.github.io/child/tags/%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用PyTorch学习NLP Chapter 1.基础介绍</title>
    <link href="http://yyukachiiii.github.io/child/2019/09/06/NLP/Chap.1/"/>
    <id>http://yyukachiiii.github.io/child/2019/09/06/NLP/Chap.1/</id>
    <published>2019-09-06T13:20:36.000Z</published>
    <updated>2019-09-09T02:51:23.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-基础介绍"><a href="#Chapter-1-基础介绍" class="headerlink" title="Chapter 1.基础介绍"></a>Chapter 1.基础介绍</h1><h4 id="The-Supervised-Learning-Paradigm（范例）"><a href="#The-Supervised-Learning-Paradigm（范例）" class="headerlink" title="The Supervised Learning Paradigm（范例）"></a>The Supervised Learning Paradigm（范例）</h4><h6 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h6><ul><li>输入(观察值)：$x$</li><li>类别标签(ground truth)：$y$</li><li>类别的预测：$\hat{y}$</li></ul><h6 id="有价值的内容"><a href="#有价值的内容" class="headerlink" title="有价值的内容"></a>有价值的内容</h6><ul><li>实际应用中很少使用随机梯度下降(SGD),因为收敛非常慢</li></ul><h4 id="Observation-And-Target-Encoding"><a href="#Observation-And-Target-Encoding" class="headerlink" title="Observation And Target Encoding"></a>Observation And Target Encoding</h4><h6 id="文本的向量表示的方法"><a href="#文本的向量表示的方法" class="headerlink" title="文本的向量表示的方法"></a>文本的向量表示的方法</h6><ul><li>One-Hot Representation<ul><li>表示成句子或文档长度乘以词表大小的矩阵</li><li>表示成一个词汇表长度的向量(一般都是使用这种表示吧…)</li></ul></li><li>TF Representation<ul><li>TF表示是构成句子的词的one-hot的总和，即向量中每个条目是相应单词在句子中出现次数的计数</li></ul></li><li>TF-IDF(Inverse Document Frequency) Representation<ul><li>在TF表示的基础上，惩罚出现次数更多地条目，奖励罕见的符号</li><li>这样的启发式表示(?什么是启发式表示？？？)在深度学习中很少使用</li></ul></li><li>Target Encoding<ul><li>按照目标任务的具体情况选择文本的向量表示</li></ul></li><li>Word Embedding<ul><li>词向量的分布式表示</li></ul></li></ul><h4 id="Computional-Graphs"><a href="#Computional-Graphs" class="headerlink" title="Computional Graphs"></a>Computional Graphs</h4><p><img src="pic/ComputionalGraph.png" alt="avatar"></p><ul><li>在计算图中，结点是乘法和加法等数学运算，输入是节点的传入边，输出是结点的传出边。</li></ul><h4 id="PyTorch-Basics"><a href="#PyTorch-Basics" class="headerlink" title="PyTorch Basics"></a>PyTorch Basics</h4><h6 id="动态计算图"><a href="#动态计算图" class="headerlink" title="动态计算图"></a>动态计算图</h6><ul><li><p>分类</p><ul><li>TensorFlow</li><li>Caffe(贾扬清开发的深度学习框架)</li><li>Theano</li></ul></li><li><p>特点</p><ul><li>在计算之前，需要声明、编译和执行计算图</li><li>计算效率高，在生产中非常有用</li></ul></li></ul><h6 id="静态计算图"><a href="#静态计算图" class="headerlink" title="静态计算图"></a>静态计算图</h6><ul><li>分类<ul><li>PyTorch</li><li>Chainer</li><li>DyNet</li></ul></li><li>特点<ul><li>更加灵活，不需要在每次执行(计算)之前再进行编译</li><li>每个输入(什么意思?)可能导致不同的图结构</li></ul></li></ul><h6 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h6><ul><li>定义</li><li>零阶张量：标量(数字)</li><li>一阶张量：向量（数字数组）</li><li>二阶张量：矩阵（向量数组）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-1-基础介绍&quot;&gt;&lt;a href=&quot;#Chapter-1-基础介绍&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1.基础介绍&quot;&gt;&lt;/a&gt;Chapter 1.基础介绍&lt;/h1&gt;&lt;h4 id=&quot;The-Supervised-Le
      
    
    </summary>
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/categories/NLP/"/>
    
      <category term="深度学习框架" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    
      <category term="PyTorch" scheme="http://yyukachiiii.github.io/child/categories/NLP/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6/PyTorch/"/>
    
    
      <category term="NLP" scheme="http://yyukachiiii.github.io/child/tags/NLP/"/>
    
      <category term="PyTorch" scheme="http://yyukachiiii.github.io/child/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>nexmoe</title>
    <link href="http://yyukachiiii.github.io/child/2019/08/29/nexmoe/"/>
    <id>http://yyukachiiii.github.io/child/2019/08/29/nexmoe/</id>
    <published>2019-08-29T01:16:49.000Z</published>
    <updated>2019-09-08T02:45:24.349Z</updated>
    
    <content type="html"><![CDATA[<p>​    从零开始学习创建基于hexo框架的主题模型。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><blockquote><p>模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档.</p></blockquote><p>​    简单来说，就是将模板文件和数据通过模板引擎生成一个HTML代码。能够让动态页面在渲染的时候，能够简化字符串的拼接操作。<img src="https://upload-images.jianshu.io/upload_images/8707272-8346cf5c4b91b284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871/format/webp" alt="avatar"></p><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ul><li><p>ejs</p><blockquote><p><font color="#19caad">EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。</font></p></blockquote></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><blockquote><p>层叠样式表(Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的<font color="#0099ff">计算机语言</font>。</p></blockquote><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><h6 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h6><blockquote><p>CSS预处理器是用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。</p></blockquote><h6 id="与CSS的关系"><a href="#与CSS的关系" class="headerlink" title="与CSS的关系"></a>与CSS的关系</h6><p>​    使用CSS语言之外的语言进行网页样式设计的代码，经过预处理器处理后，转换为标准CSS文件。</p><h2 id="代码答疑"><a href="#代码答疑" class="headerlink" title="代码答疑"></a>代码答疑</h2><h4 id="HEXO辅助函数"><a href="#HEXO辅助函数" class="headerlink" title="HEXO辅助函数"></a>HEXO辅助函数</h4><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><h6 id="partial"><a href="#partial" class="headerlink" title="partial"></a>partial</h6><ul><li>作用：载入其他模板文件，在该代码的位置插入模板文件的代码</li><li>代码：<code>&lt;%- partial(layout, [locals], [options]) %&gt;</code></li><li><a href="https://hexo.io/zh-cn/docs/helpers" target="_blank" rel="noopener">详细信息</a></li></ul><h4 id="ejs相关代码"><a href="#ejs相关代码" class="headerlink" title="ejs相关代码"></a>ejs相关代码</h4><ul><li><p>&lt;% %&gt;的作用？</p><blockquote><p>在写网页代码时，有时需要用JavaScript的逻辑代码来渲染页面，但是JavaScript的代码与HTML的代码是不一样的，不好区分。</p><p>因此使用&lt;% %&gt;来包裹住逻辑代码，方便与HTML代码进行区分。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    从零开始学习创建基于hexo框架的主题模型。&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;模板引擎&quot;&gt;&lt;a href=&quot;#模板引擎&quot; 
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yyukachiiii.github.io/child/tags/hexo/"/>
    
  </entry>
  
</feed>
